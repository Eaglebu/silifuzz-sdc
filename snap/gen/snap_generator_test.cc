// Copyright 2022 The SiliFuzz Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "./snap/gen/snap_generator.h"

#include <string.h>
#include <sys/mman.h>

#include <cstdint>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/status/statusor.h"
#include "./common/mapped_memory_map.h"
#include "./common/memory_perms.h"
#include "./common/memory_state.h"
#include "./common/snapshot.h"
#include "./snap/exit_sequence.h"
#include "./snap/snap.h"
#include "./snap/testing/snap_generator_test_lib.h"
#include "./snap/testing/snap_test_snaps.h"
#include "./snap/testing/snap_test_snapshots.h"
#include "./snap/testing/snap_test_types.h"
#include "./util/testing/status_matchers.h"

// Snap generator test.
// Test(s) below use pre-compiled Snaps in a SnapArray kSnapGeneratorTestSnaps,
// which are generated by an off-line generator from the Snapshots returned
// by MakeSnapGeneratorTestSnapshot(). We validate the generator by comparing
// the generated Snaps with the source Snapshots.

namespace silifuzz {

namespace {

using silifuzz::testing::IsOk;

SnapGenerator::Options TestSnapGeneratorOptions() {
  SnapGenerator::Options opts = SnapGenerator::Options::V2InputRunOpts();
  return opts;
}

TEST(SnapGenerator, BasicSnapGeneratorTest) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);
  const Snap& snap =
      GetSnapGeneratorTestSnap(SnapGeneratorTestType::kBasicSnapGeneratorTest);
  VerifyTestSnap(snapshot, snap, TestSnapGeneratorOptions());
}

TEST(SnapGenerator, MemoryBytesAttributesTest) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot(
      SnapGeneratorTestType::kMemoryBytesPermsTest);
  const Snap& snap =
      GetSnapGeneratorTestSnap(SnapGeneratorTestType::kMemoryBytesPermsTest);
  VerifyTestSnap(snapshot, snap, TestSnapGeneratorOptions());

  // Check that there is a code page and it is read-only.
  MappedMemoryMap code_mappings;
  for (const auto& mapping : snap.memory_mappings) {
    if (mapping.perms & PROT_EXEC) {
      EXPECT_EQ(mapping.perms & PROT_WRITE, 0);
      code_mappings.Add(mapping.start_address,
                        mapping.start_address + mapping.num_bytes,
                        MemoryPerms::FromMProtect(mapping.perms));
    }
  }
  EXPECT_FALSE(code_mappings.IsEmpty());
  // Check that any memory bytes in list that overlap with [start, limit)
  // must 1) completely lie inside [start, limit) and 2) is not writable.
  auto validate_memory_bytes_list =
      [](Snapshot::Address start, Snapshot::Address limit,
         const Snap::Array<Snap::MemoryBytes>& memory_bytes_list) {
        for (const auto& memory_bytes : memory_bytes_list) {
          const Snapshot::Address memory_bytes_limit =
              memory_bytes.start_address + memory_bytes.size();
          if (memory_bytes.start_address >= start &&
              memory_bytes_limit <= limit) {
            // memory bytes is completely inside [start,limit)
            EXPECT_EQ(memory_bytes.perms & PROT_WRITE, 0);
          } else {
            // Check that memory byte is completely outside of [start,limit).
            EXPECT_TRUE(memory_bytes_limit <= start ||
                        memory_bytes.start_address >= limit);
          }
        }
      };

  // Validate any memory bytes or end state memory bytes overlapping with
  // this code mapping.
  auto validate_one_code_mapping =
      [&snap, &validate_memory_bytes_list](
          Snapshot::Address start, Snapshot::Address limit, MemoryPerms perms) {
        validate_memory_bytes_list(start, limit, snap.memory_bytes);
        validate_memory_bytes_list(start, limit, snap.end_state_memory_bytes);
      };

  code_mappings.Iterate(validate_one_code_mapping);
}

TEST(SnapGenerator, Snapify) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);
  SnapGenerator::Options options = TestSnapGeneratorOptions();
  const absl::StatusOr<Snapshot> snapified_or =
      SnapGenerator::Snapify(snapshot, options);
  ASSERT_THAT(snapified_or, IsOk());

  for (const auto& mapping : snapified_or->memory_mappings()) {
    MemoryPerms original_perms = snapshot.PermsAt(mapping.start_address());
    const MemoryPerms expected = original_perms;
    EXPECT_EQ(mapping.perms().DebugString(), expected.DebugString());
  }

  // Check that we have the exit sequence in the initial memory bytes.
  MemoryState initial_memory_state = MemoryState::MakeInitial(
      *snapified_or, MemoryState::kSnapshotOnly, MemoryState::kZeroMappedBytes);

  const Snapshot::EndState snapified_end_state =
      snapified_or->expected_end_states()[0];
  const Snapshot::Address snapified_end_state_rip =
      snapified_end_state.endpoint().instruction_address();
  CHECK(initial_memory_state.mapped_memory().Contains(
      snapified_end_state_rip,
      snapified_end_state_rip + kSnapExitSequenceSize));
  const Snapshot::ByteData exit_sequence = initial_memory_state.memory_bytes(
      snapified_end_state_rip, kSnapExitSequenceSize);
  uint8_t expected_exit_sequence[kSnapExitSequenceSize];
  WriteSnapExitSequence(expected_exit_sequence);
  CHECK_EQ(memcmp(exit_sequence.data(), expected_exit_sequence,
                  kSnapExitSequenceSize),
           0);

  // Check that we have the exit sequence stack artifact.
  const Snapshot::Address snapfied_end_state_rsp =
      snapified_or->ExtractRsp(snapified_end_state.registers());

  MemoryState end_memory_state =
      MemoryState::MakeEnd(*snapified_or, MemoryState::kSnapshotOnly, 0,
                           MemoryState::kZeroMappedBytes);
  const uint64_t expected_return_address =
      snapified_end_state_rip + kSnapExitSequenceSize - 8;

  // Snapify() does not correct the end state rsp to account for a return
  // address pushed by the exiting call.  So we check [rsp-8, rsp) here
  // instead of [rsp, rsp+8).
  //
  // TODO(dougkwan): [cleanup] Fix Snapify(), RunnerReentry() and this test
  // together so that snapified end state rsp is origin rsp + 8, which is
  // what we expect when an extra 8 bytes are pushed.
  CHECK(end_memory_state.mapped_memory().Contains(snapfied_end_state_rsp - 8,
                                                  snapfied_end_state_rsp));
  const Snapshot::ByteData return_address_bytes =
      end_memory_state.memory_bytes(snapfied_end_state_rsp - 8, 8);
  CHECK_EQ(memcmp(return_address_bytes.data(), &expected_return_address, 8), 0);

  // All end state memory bytes must be writable as in the original snapshot.
  // There should not be read-only memory bytes.
  for (const auto& memory_bytes : snapified_end_state.memory_bytes()) {
    EXPECT_TRUE(snapshot.mapped_memory_map()
                    .PermsAt(memory_bytes.start_address())
                    .Has(MemoryPerms::kWritable));
  }
}

TEST(SnapGenerator, SnapifyIdempotent) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);
  const absl::StatusOr<Snapshot> snapified_or =
      SnapGenerator::Snapify(snapshot);
  ASSERT_THAT(snapified_or, IsOk());
  // snapified is now a v2-format
  auto opts = SnapGenerator::Options::V2InputRunOpts();
  const auto snapified2 = SnapGenerator::Snapify(*snapified_or, opts);
  ASSERT_THAT(snapified2, IsOk());
  ASSERT_EQ(*snapified_or, *snapified2);
}

}  // namespace
}  // namespace silifuzz
