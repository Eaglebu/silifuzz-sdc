// Copyright 2022 The SiliFuzz Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "./snap/gen/snap_generator.h"

#include <stddef.h>
#include <sys/mman.h>

#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/status/status.h"
#include "./common/mapped_memory_map.h"
#include "./common/memory_perms.h"
#include "./common/memory_state.h"
#include "./common/snapshot.h"
#include "./snap/exit_sequence.h"
#include "./snap/testing/snap_test_snapshots.h"
#include "./snap/testing/snap_test_types.h"
#include "./util/arch.h"
#include "./util/testing/status_macros.h"
#include "./util/testing/status_matchers.h"

// Snap generator test.
// Test(s) below use pre-compiled Snaps in a SnapArray kSnapGeneratorTestSnaps,
// which are generated by an off-line generator from the Snapshots returned
// by MakeSnapGeneratorTestSnapshot(). We validate the generator by comparing
// the generated Snaps with the source Snapshots.

namespace silifuzz {

namespace {
using silifuzz::testing::StatusIs;

TEST(SnapGenerator, Snapify) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot<Host>(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified,
                       Snapify(snapshot, SnapifyOptions::V2InputRunOpts(
                                             snapshot.architecture_id())));

  for (const auto& mapping : snapified.memory_mappings()) {
    MemoryPerms expected_perms = snapshot.PermsAt(mapping.start_address());
    EXPECT_EQ(mapping.perms().DebugString(), expected_perms.DebugString());
  }

  // Check that we have the exit sequence in the initial memory bytes.
  MemoryState initial_memory_state =
      MemoryState::MakeInitial(snapified, MemoryState::kZeroMappedBytes);

  const Snapshot::EndState snapified_end_state =
      snapified.expected_end_states()[0];
  const Snapshot::Address snapified_end_state_rip =
      snapified_end_state.endpoint().instruction_address();
  const size_t exit_sequence_size = GetSnapExitSequenceSize<Host>();
  ASSERT_TRUE(initial_memory_state.mapped_memory().Contains(
      snapified_end_state_rip, snapified_end_state_rip + exit_sequence_size));
  const Snapshot::ByteData exit_sequence = initial_memory_state.memory_bytes(
      snapified_end_state_rip, exit_sequence_size);
  std::string expected_exit_sequence(exit_sequence_size, 0);
  WriteSnapExitSequence<Host>(expected_exit_sequence.data());
  EXPECT_EQ(exit_sequence, expected_exit_sequence);

  // All end state memory bytes must be writable as in the original snapshot.
  // There should not be read-only memory bytes.
  for (const auto& memory_bytes : snapified_end_state.memory_bytes()) {
    EXPECT_TRUE(snapshot.mapped_memory_map()
                    .PermsAt(memory_bytes.start_address())
                    .Has(MemoryPerms::kWritable));
    initial_memory_state.RemoveMemoryMapping(memory_bytes.start_address(),
                                             memory_bytes.limit_address());
  }
  initial_memory_state.mapped_memory().Iterate(
      [&initial_memory_state](auto start, auto limit, auto p) {
        EXPECT_FALSE(p.Has(MemoryPerms::kWritable))
            << "Expected that all writable pages are present in the end state. "
            << "Snapshot mappings missing from end state: "
            << initial_memory_state.mapped_memory().DebugString();
      });
}

TEST(SnapGenerator, SnapifyIdempotent) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot<Host>(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);

  SnapifyOptions opts =
      SnapifyOptions::V2InputRunOpts(snapshot.architecture_id());
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified, Snapify(snapshot, opts));
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified2, Snapify(snapified, opts));
  ASSERT_EQ(snapified, snapified2);
}

TEST(SnapGenerator, SnapifyMerge) {
  Snapshot original = MakeSnapGeneratorTestSnapshot<Host>(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);

  // Arbitrary address that shouldn't collide with the test snapshot.
  Snapshot::Address aux_data_address = 0x90000000ULL;
  size_t aux_data_size = 0x2000;
  // Check there's nothing there.
  ASSERT_EQ(original.PermsAt(aux_data_address), MemoryPerms::None());

  // Create a snapshot with two adjacent data ranges.
  Snapshot modified = original.Copy();
  modified.add_memory_mapping(Snapshot::MemoryMapping::MakeSized(
      aux_data_address, aux_data_size, MemoryPerms::RW()));
  modified.add_memory_mapping(Snapshot::MemoryMapping::MakeSized(
      aux_data_address + aux_data_size, aux_data_size, MemoryPerms::RW()));

  // Create a snapshot with those ranges merged.
  Snapshot expected = original.Copy();
  expected.add_memory_mapping(Snapshot::MemoryMapping::MakeSized(
      aux_data_address, aux_data_size * 2, MemoryPerms::RW()));

  // Snapify everything.
  SnapifyOptions opts =
      SnapifyOptions::V2InputRunOpts(original.architecture_id());
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified_original,
                       Snapify(original, opts));
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified_modified,
                       Snapify(modified, opts));
  ASSERT_OK_AND_ASSIGN(const Snapshot snapified_expected,
                       Snapify(expected, opts));

  // Note: checking the mappings are equal rather than the Snapshot because the
  // Snapshot equals doesn't check the mappings directly.

  // Make sure adding the mappings gave us a different result.
  EXPECT_NE(snapified_original.memory_mappings(),
            snapified_modified.memory_mappings());

  // Make sure the mappings got merged.
  EXPECT_EQ(snapified_expected.memory_mappings(),
            snapified_modified.memory_mappings());
}

TEST(SnapGenerator, CanSnapify) {
  Snapshot snapshot = MakeSnapGeneratorTestSnapshot<Host>(
      SnapGeneratorTestType::kBasicSnapGeneratorTest);
  snapshot.set_expected_end_states({});
  SnapifyOptions opts =
      SnapifyOptions::V2InputRunOpts(snapshot.architecture_id());
  EXPECT_THAT(CanSnapify(snapshot, opts),
              StatusIs(absl::StatusCode::kNotFound));
  EXPECT_THAT(Snapify(snapshot, opts), StatusIs(absl::StatusCode::kNotFound));
}

}  // namespace
}  // namespace silifuzz
